<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LogCabin: LogCabin::Client::Tree Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">LogCabin
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceLogCabin.html">LogCabin</a>      </li>
      <li class="navelem"><a class="el" href="namespaceLogCabin_1_1Client.html">Client</a>      </li>
      <li class="navelem"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html">Tree</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">LogCabin::Client::Tree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="LogCabin::Client::Tree" -->
<p>Provides access to the hierarchical key-value store.  
 <a href="classLogCabin_1_1Client_1_1Tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Client_8h_source.html">Client.h</a>&gt;</code></p>

<p><a href="classLogCabin_1_1Client_1_1Tree-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a0e9489da8bd1c64b4ba084e51802fea0">Tree</a> (const <a class="el" href="classLogCabin_1_1Client_1_1Tree.html">Tree</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a0e9489da8bd1c64b4ba084e51802fea0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html">Tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a9471612f3853b0dbd4ef887c907b3984">operator=</a> (const <a class="el" href="classLogCabin_1_1Client_1_1Tree.html">Tree</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a9471612f3853b0dbd4ef887c907b3984"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a07c084bb7f7edcf304f781b5a8e78fb6">setWorkingDirectory</a> (const std::string &amp;workingDirectory)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the working directory for this object.  <a href="#a07c084bb7f7edcf304f781b5a8e78fb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a8b0226fa7c718ff6037d36d06d917651">setWorkingDirectoryEx</a> (const std::string &amp;workingDirectory)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like setWorkingDirectory but throws exceptions upon errors.  <a href="#a8b0226fa7c718ff6037d36d06d917651"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a0c9326ee756d5a1f242536787fbeb248">getWorkingDirectory</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the working directory for this object.  <a href="#a0c9326ee756d5a1f242536787fbeb248"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a9f2ed93957c3a8704bad0734f48fe350">getCondition</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the condition set by a previous call to <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a>.  <a href="#a9f2ed93957c3a8704bad0734f48fe350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921">setCondition</a> (const std::string &amp;path, const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a predicate on all future operations.  <a href="#aa2b64e58dccb96f0458b09da95151921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa34bfb2a34b8cfe8b9be35105d1c1d97">setConditionEx</a> (const std::string &amp;path, const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like setCondition but throws exceptions upon errors.  <a href="#aa34bfb2a34b8cfe8b9be35105d1c1d97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a66fc90296aaa481069575394cbf5933b">getTimeout</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the timeout set by a previous call to <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#ac0f658f32b73a9daba01889040180ca7" title="Abort each future operation if it may not have completed within the specified period of time...">setTimeout()</a>.  <a href="#a66fc90296aaa481069575394cbf5933b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#ac0f658f32b73a9daba01889040180ca7">setTimeout</a> (uint64_t nanoseconds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort each future operation if it may not have completed within the specified period of time.  <a href="#ac0f658f32b73a9daba01889040180ca7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a2bd59073257f11c2f458bd05d7aa9cc3">makeDirectory</a> (const std::string &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure a directory exists at the given path.  <a href="#a2bd59073257f11c2f458bd05d7aa9cc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa5a402128a5beb6cb29206cea7e747a1">makeDirectoryEx</a> (const std::string &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like makeDirectory but throws exceptions upon errors.  <a href="#aa5a402128a5beb6cb29206cea7e747a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a05bf4e0eef288dd3ccf33f76f9b6c6d3">listDirectory</a> (const std::string &amp;path, std::vector&lt; std::string &gt; &amp;children) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List the contents of a directory.  <a href="#a05bf4e0eef288dd3ccf33f76f9b6c6d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a922e4fb2066c5a349f75bd52bbcc5401">listDirectoryEx</a> (const std::string &amp;path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like listDirectory but throws exceptions upon errors.  <a href="#a922e4fb2066c5a349f75bd52bbcc5401"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#adab277ed481a6c60219ba14816235566">removeDirectory</a> (const std::string &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure a directory does not exist.  <a href="#adab277ed481a6c60219ba14816235566"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a2fadcb7b360a472d2976136d0e1648a9">removeDirectoryEx</a> (const std::string &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like removeDirectory but throws exceptions upon errors.  <a href="#a2fadcb7b360a472d2976136d0e1648a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a200592adcfe3460c336d4ae31078d456">write</a> (const std::string &amp;path, const std::string &amp;contents)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a file.  <a href="#a200592adcfe3460c336d4ae31078d456"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a7adc0dc51d075347f76fe28828d94c58">writeEx</a> (const std::string &amp;path, const std::string &amp;contents)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like write but throws exceptions upon errors.  <a href="#a7adc0dc51d075347f76fe28828d94c58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a74c016d6333e5548edd2873baff605c4">read</a> (const std::string &amp;path, std::string &amp;contents) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a file.  <a href="#a74c016d6333e5548edd2873baff605c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#ae55cbfaac8a0b5a6ae396544db8d2038">readEx</a> (const std::string &amp;path) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like read but throws exceptions upon errors.  <a href="#ae55cbfaac8a0b5a6ae396544db8d2038"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a7dd317fe97e655550b9029453f028d4b">removeFile</a> (const std::string &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure a file does not exist.  <a href="#a7dd317fe97e655550b9029453f028d4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a154a111f2ff1cbc57b1c29cac59567ae">removeFileEx</a> (const std::string &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Like removeFile but throws exceptions upon errors.  <a href="#a154a111f2ff1cbc57b1c29cac59567ae"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a9c11695109d32373d099470ba38b0f2b">Tree</a> (std::shared_ptr&lt; <a class="el" href="classLogCabin_1_1Client_1_1ClientImpl.html">ClientImpl</a> &gt; clientImpl, const std::string &amp;workingDirectory)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a9c11695109d32373d099470ba38b0f2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <br class="typebreak"/>
<a class="el" href="classLogCabin_1_1Client_1_1TreeDetails.html">TreeDetails</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a08946f4a9011e8143ba4cf0147a77514">getTreeDetails</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the implementation-specific members of this class.  <a href="#a08946f4a9011e8143ba4cf0147a77514"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a4253d99a59b7052d5946353e899e291d">mutex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides mutual exclusion to treeDetails pointer.  <a href="#a4253d99a59b7052d5946353e899e291d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <br class="typebreak"/>
<a class="el" href="classLogCabin_1_1Client_1_1TreeDetails.html">TreeDetails</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa226e2ed8ef8fd4ac53467fb88826646">treeDetails</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference-counted pointer to implementation-specific members.  <a href="#aa226e2ed8ef8fd4ac53467fb88826646"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a037e8c5141681b4bc50ecf53f86a58e6">Cluster</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Provides access to the hierarchical key-value store. </p>
<p>You can get an instance of <a class="el" href="classLogCabin_1_1Client_1_1Tree.html" title="Provides access to the hierarchical key-value store.">Tree</a> through <a class="el" href="classLogCabin_1_1Client_1_1Cluster.html#ab04d52131d9ddb8c0aa140c359dc2841" title="Return an object to access the hierarchical key-value store.">Cluster::getTree()</a> or by copying an existing <a class="el" href="classLogCabin_1_1Client_1_1Tree.html" title="Provides access to the hierarchical key-value store.">Tree</a>.</p>
<p>A <a class="el" href="classLogCabin_1_1Client_1_1Tree.html" title="Provides access to the hierarchical key-value store.">Tree</a> has a working directory from which all relative paths (those that do not begin with a '/' are resolved). This allows different applications and modules to conveniently access their own subtrees -- they can have their own <a class="el" href="classLogCabin_1_1Client_1_1Tree.html" title="Provides access to the hierarchical key-value store.">Tree</a> instances and set their working directories accordingly.</p>
<p>Methods that can fail come in two flavors. The first flavor returns <a class="el" href="structLogCabin_1_1Client_1_1Result.html" title="Returned by Tree operations; contain a status code and an error message.">Result</a> values with error codes and messages; the second throws exceptions upon errors. These can be distinguished by the "Ex" suffix in the names of methods that throw exceptions. </p>

<p>Definition at line <a class="el" href="Client_8h_source.html#l00321">321</a> of file <a class="el" href="Client_8h_source.html">Client.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9c11695109d32373d099470ba38b0f2b"></a><!-- doxytag: member="LogCabin::Client::Tree::Tree" ref="a9c11695109d32373d099470ba38b0f2b" args="(std::shared_ptr&lt; ClientImpl &gt; clientImpl, const std::string &amp;workingDirectory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a9c11695109d32373d099470ba38b0f2b">LogCabin::Client::Tree::Tree</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classLogCabin_1_1Client_1_1ClientImpl.html">ClientImpl</a> &gt;&#160;</td>
          <td class="paramname"><em>clientImpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>workingDirectory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00227">227</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0e9489da8bd1c64b4ba084e51802fea0"></a><!-- doxytag: member="LogCabin::Client::Tree::Tree" ref="a0e9489da8bd1c64b4ba084e51802fea0" args="(const Tree &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a9c11695109d32373d099470ba38b0f2b">LogCabin::Client::Tree::Tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLogCabin_1_1Client_1_1Tree.html">Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00234">234</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9471612f3853b0dbd4ef887c907b3984"></a><!-- doxytag: member="LogCabin::Client::Tree::operator=" ref="a9471612f3853b0dbd4ef887c907b3984" args="(const Tree &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Client_1_1Tree.html">Tree</a> &amp; LogCabin::Client::Tree::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLogCabin_1_1Client_1_1Tree.html">Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00241">241</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a07c084bb7f7edcf304f781b5a8e78fb6"></a><!-- doxytag: member="LogCabin::Client::Tree::setWorkingDirectory" ref="a07c084bb7f7edcf304f781b5a8e78fb6" args="(const std::string &amp;workingDirectory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a> <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a07c084bb7f7edcf304f781b5a8e78fb6">LogCabin::Client::Tree::setWorkingDirectory</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>workingDirectory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the working directory for this object. </p>
<p>This directory will be created if it does not exist. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">workingDirectory</td><td>The new working directory, which may be relative to the current working directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status and error message. Possible errors are:<ul>
<li>INVALID_ARGUMENT if workingDirectory is malformed.</li>
<li>TYPE_ERROR if parent of workingDirectory is a file.</li>
<li>TYPE_ERROR if workingDirectory exists but is a file.</li>
<li>CONDITION_NOT_MET if predicate from <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a> was false.</li>
<li>TIMEOUT if timeout elapsed before the operation completed. If this returns an error, future operations on this tree using relative paths will fail until a valid working directory is set. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00252">252</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8b0226fa7c718ff6037d36d06d917651"></a><!-- doxytag: member="LogCabin::Client::Tree::setWorkingDirectoryEx" ref="a8b0226fa7c718ff6037d36d06d917651" args="(const std::string &amp;workingDirectory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a8b0226fa7c718ff6037d36d06d917651">LogCabin::Client::Tree::setWorkingDirectoryEx</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>workingDirectory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like setWorkingDirectory but throws exceptions upon errors. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00286">286</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0c9326ee756d5a1f242536787fbeb248"></a><!-- doxytag: member="LogCabin::Client::Tree::getWorkingDirectory" ref="a0c9326ee756d5a1f242536787fbeb248" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a0c9326ee756d5a1f242536787fbeb248">LogCabin::Client::Tree::getWorkingDirectory</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the working directory for this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An absolute path that is the prefix for relative paths used with this <a class="el" href="classLogCabin_1_1Client_1_1Tree.html" title="Provides access to the hierarchical key-value store.">Tree</a> object. </dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00293">293</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9f2ed93957c3a8704bad0734f48fe350"></a><!-- doxytag: member="LogCabin::Client::Tree::getCondition" ref="a9f2ed93957c3a8704bad0734f48fe350" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a9f2ed93957c3a8704bad0734f48fe350">LogCabin::Client::Tree::getCondition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the condition set by a previous call to <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>First component: the absolute path corresponding to the 'path' argument of <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a>. Second component: the file contents given as the 'value' argument of <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a>. </dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00341">341</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa2b64e58dccb96f0458b09da95151921"></a><!-- doxytag: member="LogCabin::Client::Tree::setCondition" ref="aa2b64e58dccb96f0458b09da95151921" args="(const std::string &amp;path, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a> <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921">LogCabin::Client::Tree::setCondition</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a predicate on all future operations. </p>
<p>Future operations will return Status::CONDITION_NOT_MET and have no effect unless the file at 'path' has the contents 'value'. To remove the predicate, pass an empty string as 'path'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The relative or absolute path to the file that must have the contents specified in value, or an empty string to clear the condition. </td></tr>
    <tr><td class="paramname">value</td><td>The contents that the file specified by 'path' must have for future operations to succeed. If 'value' is the empty string and the file does not exist, the condition will also be satisfied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status and error message. Possible errors are:<ul>
<li>INVALID_ARGUMENT if path is malformed. If this returns an error, future operations on this tree will fail until a new condition is set or the condition is cleared. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00300">300</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa34bfb2a34b8cfe8b9be35105d1c1d97"></a><!-- doxytag: member="LogCabin::Client::Tree::setConditionEx" ref="aa34bfb2a34b8cfe8b9be35105d1c1d97" args="(const std::string &amp;path, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa34bfb2a34b8cfe8b9be35105d1c1d97">LogCabin::Client::Tree::setConditionEx</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like setCondition but throws exceptions upon errors. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00335">335</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a66fc90296aaa481069575394cbf5933b"></a><!-- doxytag: member="LogCabin::Client::Tree::getTimeout" ref="a66fc90296aaa481069575394cbf5933b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a66fc90296aaa481069575394cbf5933b">LogCabin::Client::Tree::getTimeout</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the timeout set by a previous call to <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#ac0f658f32b73a9daba01889040180ca7" title="Abort each future operation if it may not have completed within the specified period of time...">setTimeout()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum duration of each operation (in nanoseconds), or 0 for no timeout. </dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00348">348</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac0f658f32b73a9daba01889040180ca7"></a><!-- doxytag: member="LogCabin::Client::Tree::setTimeout" ref="ac0f658f32b73a9daba01889040180ca7" args="(uint64_t nanoseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#ac0f658f32b73a9daba01889040180ca7">LogCabin::Client::Tree::setTimeout</a> </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nanoseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort each future operation if it may not have completed within the specified period of time. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The client library does not currently implement timeouts for DNS lookups. See <a href="https://github.com/logcabin/logcabin/issues/75">https://github.com/logcabin/logcabin/issues/75</a> </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nanoseconds</td><td>The maximum duration of each operation (in nanoseconds). Set to 0 for no timeout. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00355">355</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a2bd59073257f11c2f458bd05d7aa9cc3"></a><!-- doxytag: member="LogCabin::Client::Tree::makeDirectory" ref="a2bd59073257f11c2f458bd05d7aa9cc3" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a> <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a2bd59073257f11c2f458bd05d7aa9cc3">LogCabin::Client::Tree::makeDirectory</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make sure a directory exists at the given path. </p>
<p>Create parent directories listed in path as necessary. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path where there should be a directory after this call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status and error message. Possible errors are:<ul>
<li>INVALID_ARGUMENT if path is malformed.</li>
<li>TYPE_ERROR if a parent of path is a file.</li>
<li>TYPE_ERROR if path exists but is a file.</li>
<li>CONDITION_NOT_MET if predicate from <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a> was false.</li>
<li>TIMEOUT if timeout elapsed before the operation completed. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00364">364</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa5a402128a5beb6cb29206cea7e747a1"></a><!-- doxytag: member="LogCabin::Client::Tree::makeDirectoryEx" ref="aa5a402128a5beb6cb29206cea7e747a1" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa5a402128a5beb6cb29206cea7e747a1">LogCabin::Client::Tree::makeDirectoryEx</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like makeDirectory but throws exceptions upon errors. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00375">375</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a05bf4e0eef288dd3ccf33f76f9b6c6d3"></a><!-- doxytag: member="LogCabin::Client::Tree::listDirectory" ref="a05bf4e0eef288dd3ccf33f76f9b6c6d3" args="(const std::string &amp;path, std::vector&lt; std::string &gt; &amp;children) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a> <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a05bf4e0eef288dd3ccf33f76f9b6c6d3">LogCabin::Client::Tree::listDirectory</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List the contents of a directory. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">path</td><td>The directory whose direct children to list. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">children</td><td>This will be replaced by a listing of the names of the directories and files that the directory at 'path' immediately contains. The names of directories in this listing will have a trailing slash. The order is first directories (sorted lexicographically), then files (sorted lexicographically). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status and error message. Possible errors are:<ul>
<li>INVALID_ARGUMENT if path is malformed.</li>
<li>LOOKUP_ERROR if a parent of path does not exist.</li>
<li>LOOKUP_ERROR if path does not exist.</li>
<li>TYPE_ERROR if a parent of path is a file.</li>
<li>TYPE_ERROR if path exists but is a file.</li>
<li>CONDITION_NOT_MET if predicate from <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a> was false.</li>
<li>TIMEOUT if timeout elapsed before the operation completed. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00381">381</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a922e4fb2066c5a349f75bd52bbcc5401"></a><!-- doxytag: member="LogCabin::Client::Tree::listDirectoryEx" ref="a922e4fb2066c5a349f75bd52bbcc5401" args="(const std::string &amp;path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a922e4fb2066c5a349f75bd52bbcc5401">LogCabin::Client::Tree::listDirectoryEx</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like listDirectory but throws exceptions upon errors. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00394">394</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="adab277ed481a6c60219ba14816235566"></a><!-- doxytag: member="LogCabin::Client::Tree::removeDirectory" ref="adab277ed481a6c60219ba14816235566" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a> <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#adab277ed481a6c60219ba14816235566">LogCabin::Client::Tree::removeDirectory</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make sure a directory does not exist. </p>
<p>Also removes all direct and indirect children of the directory.</p>
<p>If called with the root directory, this will remove all descendants but not actually remove the root directory; it will still return status OK.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path where there should not be a directory after this call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status and error message. Possible errors are:<ul>
<li>INVALID_ARGUMENT if path is malformed.</li>
<li>TYPE_ERROR if a parent of path is a file.</li>
<li>TYPE_ERROR if path exists but is a file.</li>
<li>CONDITION_NOT_MET if predicate from <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a> was false.</li>
<li>TIMEOUT if timeout elapsed before the operation completed. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00402">402</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a2fadcb7b360a472d2976136d0e1648a9"></a><!-- doxytag: member="LogCabin::Client::Tree::removeDirectoryEx" ref="a2fadcb7b360a472d2976136d0e1648a9" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a2fadcb7b360a472d2976136d0e1648a9">LogCabin::Client::Tree::removeDirectoryEx</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like removeDirectory but throws exceptions upon errors. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00413">413</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a200592adcfe3460c336d4ae31078d456"></a><!-- doxytag: member="LogCabin::Client::Tree::write" ref="a200592adcfe3460c336d4ae31078d456" args="(const std::string &amp;path, const std::string &amp;contents)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a> <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a200592adcfe3460c336d4ae31078d456">LogCabin::Client::Tree::write</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the value of a file. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path where there should be a file with the given contents after this call. </td></tr>
    <tr><td class="paramname">contents</td><td>The new value associated with the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status and error message. Possible errors are:<ul>
<li>INVALID_ARGUMENT if path is malformed.</li>
<li>INVALID_ARGUMENT if contents are too large to fit in a file.</li>
<li>LOOKUP_ERROR if a parent of path does not exist.</li>
<li>TYPE_ERROR if a parent of path is a file.</li>
<li>TYPE_ERROR if path exists but is a directory.</li>
<li>CONDITION_NOT_MET if predicate from <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a> was false.</li>
<li>TIMEOUT if timeout elapsed before the operation completed. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00419">419</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a7adc0dc51d075347f76fe28828d94c58"></a><!-- doxytag: member="LogCabin::Client::Tree::writeEx" ref="a7adc0dc51d075347f76fe28828d94c58" args="(const std::string &amp;path, const std::string &amp;contents)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a7adc0dc51d075347f76fe28828d94c58">LogCabin::Client::Tree::writeEx</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like write but throws exceptions upon errors. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00431">431</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a74c016d6333e5548edd2873baff605c4"></a><!-- doxytag: member="LogCabin::Client::Tree::read" ref="a74c016d6333e5548edd2873baff605c4" args="(const std::string &amp;path, std::string &amp;contents) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a> <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a74c016d6333e5548edd2873baff605c4">LogCabin::Client::Tree::read</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>contents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value of a file. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the file whose contents to read. </td></tr>
    <tr><td class="paramname">contents</td><td>The current value associated with the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status and error message. Possible errors are:<ul>
<li>INVALID_ARGUMENT if path is malformed.</li>
<li>LOOKUP_ERROR if a parent of path does not exist.</li>
<li>LOOKUP_ERROR if path does not exist.</li>
<li>TYPE_ERROR if a parent of path is a file.</li>
<li>TYPE_ERROR if path is a directory.</li>
<li>CONDITION_NOT_MET if predicate from <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a> was false.</li>
<li>TIMEOUT if timeout elapsed before the operation completed. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00437">437</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae55cbfaac8a0b5a6ae396544db8d2038"></a><!-- doxytag: member="LogCabin::Client::Tree::readEx" ref="ae55cbfaac8a0b5a6ae396544db8d2038" args="(const std::string &amp;path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#ae55cbfaac8a0b5a6ae396544db8d2038">LogCabin::Client::Tree::readEx</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like read but throws exceptions upon errors. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00449">449</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a7dd317fe97e655550b9029453f028d4b"></a><!-- doxytag: member="LogCabin::Client::Tree::removeFile" ref="a7dd317fe97e655550b9029453f028d4b" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLogCabin_1_1Client_1_1Result.html">Result</a> <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a7dd317fe97e655550b9029453f028d4b">LogCabin::Client::Tree::removeFile</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make sure a file does not exist. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path where there should not be a file after this call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status and error message. Possible errors are:<ul>
<li>INVALID_ARGUMENT if path is malformed.</li>
<li>TYPE_ERROR if a parent of path is a file.</li>
<li>TYPE_ERROR if path exists but is a directory.</li>
<li>CONDITION_NOT_MET if predicate from <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa2b64e58dccb96f0458b09da95151921" title="Set a predicate on all future operations.">setCondition()</a> was false.</li>
<li>TIMEOUT if timeout elapsed before the operation completed. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00457">457</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a154a111f2ff1cbc57b1c29cac59567ae"></a><!-- doxytag: member="LogCabin::Client::Tree::removeFileEx" ref="a154a111f2ff1cbc57b1c29cac59567ae" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a154a111f2ff1cbc57b1c29cac59567ae">LogCabin::Client::Tree::removeFileEx</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like removeFile but throws exceptions upon errors. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00468">468</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a08946f4a9011e8143ba4cf0147a77514"></a><!-- doxytag: member="LogCabin::Client::Tree::getTreeDetails" ref="a08946f4a9011e8143ba4cf0147a77514" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classLogCabin_1_1Client_1_1TreeDetails.html">TreeDetails</a> &gt; <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a08946f4a9011e8143ba4cf0147a77514">LogCabin::Client::Tree::getTreeDetails</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference to the implementation-specific members of this class. </p>

<p>Definition at line <a class="el" href="Client_8cc_source.html#l00474">474</a> of file <a class="el" href="Client_8cc_source.html">Client.cc</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a037e8c5141681b4bc50ecf53f86a58e6"></a><!-- doxytag: member="LogCabin::Client::Tree::Cluster" ref="a037e8c5141681b4bc50ecf53f86a58e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLogCabin_1_1Client_1_1Cluster.html">Cluster</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Client_8h_source.html#l00582">582</a> of file <a class="el" href="Client_8h_source.html">Client.h</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a4253d99a59b7052d5946353e899e291d"></a><!-- doxytag: member="LogCabin::Client::Tree::mutex" ref="a4253d99a59b7052d5946353e899e291d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#a4253d99a59b7052d5946353e899e291d">LogCabin::Client::Tree::mutex</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides mutual exclusion to treeDetails pointer. </p>

<p>Definition at line <a class="el" href="Client_8h_source.html#l00575">575</a> of file <a class="el" href="Client_8h_source.html">Client.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa226e2ed8ef8fd4ac53467fb88826646"></a><!-- doxytag: member="LogCabin::Client::Tree::treeDetails" ref="aa226e2ed8ef8fd4ac53467fb88826646" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classLogCabin_1_1Client_1_1TreeDetails.html">TreeDetails</a>&gt; <a class="el" href="classLogCabin_1_1Client_1_1Tree.html#aa226e2ed8ef8fd4ac53467fb88826646">LogCabin::Client::Tree::treeDetails</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reference-counted pointer to implementation-specific members. </p>
<p>This is copy-on-write, so 'mutex' need not be held after taking a reference to treeDetails. </p>

<p>Definition at line <a class="el" href="Client_8h_source.html#l00581">581</a> of file <a class="el" href="Client_8h_source.html">Client.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/LogCabin/<a class="el" href="Client_8h_source.html">Client.h</a></li>
<li>Client/<a class="el" href="Client_8cc_source.html">Client.cc</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
