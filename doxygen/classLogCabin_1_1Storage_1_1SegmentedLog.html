<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LogCabin: LogCabin::Storage::SegmentedLog Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">LogCabin
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceLogCabin.html">LogCabin</a>      </li>
      <li class="navelem"><a class="el" href="namespaceLogCabin_1_1Storage.html">Storage</a>      </li>
      <li class="navelem"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html">SegmentedLog</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">LogCabin::Storage::SegmentedLog Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="LogCabin::Storage::SegmentedLog" --><!-- doxytag: inherits="LogCabin::Storage::Log" -->
<p>This class persists a log on the filesystem efficiently.  
 <a href="classLogCabin_1_1Storage_1_1SegmentedLog.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LogCabin::Storage::SegmentedLog:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classLogCabin_1_1Storage_1_1SegmentedLog.png" usemap="#LogCabin::Storage::SegmentedLog_map" alt=""/>
  <map id="LogCabin::Storage::SegmentedLog_map" name="LogCabin::Storage::SegmentedLog_map">
<area href="classLogCabin_1_1Storage_1_1Log.html" title="This interface is used by RaftConsensus to store log entries and metadata." alt="LogCabin::Storage::Log" shape="rect" coords="0,0,205,24"/>
</map>
 </div></div>

<p><a href="classLogCabin_1_1Storage_1_1SegmentedLog-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1PreparedSegments.html">PreparedSegments</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A producer/consumer monitor for a queue of files to use for open segments.  <a href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1PreparedSegments.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An open or closed segment.  <a href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1SegmentHeader.html">SegmentHeader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This goes at the start of every segment.  <a href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1SegmentHeader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html">Sync</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues various operations on files, such as writes and fsyncs, to be executed later.  <a href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5503ea75df765ff0302604d2c0f9cfdf">Encoding</a> { <br/>
&#160;&#160;<a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5503ea75df765ff0302604d2c0f9cfdfa5db6da2c8f11776b6ecde090b58f0dd9">TEXT</a>, 
<br/>
&#160;&#160;<a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5503ea75df765ff0302604d2c0f9cfdfa7e0644cff2ba996c4e8b01bf72ed6820">BINARY</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how individual records are serialized.  <a href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5503ea75df765ff0302604d2c0f9cfdf">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab667337be23393a649a61ca8f515af7b">SegmentedLog</a> (const <a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FilesystemUtil::File</a> &amp;parentDir, <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5503ea75df765ff0302604d2c0f9cfdf">Encoding</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a20c878fca260c1fea2dbae7905ce827e">encoding</a>, const <a class="el" href="classLogCabin_1_1Core_1_1Config.html">Core::Config</a> &amp;config)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ab667337be23393a649a61ca8f515af7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a3665b28b42b618a022ab40ed88969345">~SegmentedLog</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ae0b3ea9703e373566d879928296eae16">append</a> (const std::vector&lt; const <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a8ca64ace5d6ae6f0175186c595d4fbe0">Entry</a> * &gt; &amp;entries)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start to append new entries to the log.  <a href="#ae0b3ea9703e373566d879928296eae16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a8ca64ace5d6ae6f0175186c595d4fbe0">Entry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#af54cbc6f31d77719f3fe8d699b5c94da">getEntry</a> (uint64_t) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an entry by its log index.  <a href="#af54cbc6f31d77719f3fe8d699b5c94da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad729715c9512554255bb0670f6c385a2">getLogStartIndex</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first entry in the log (whether or not this entry exists).  <a href="#ad729715c9512554255bb0670f6c385a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a45c575000cfd56c3d77d6efa7a6286de">getLastLogIndex</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the most recent entry in the log.  <a href="#a45c575000cfd56c3d77d6efa7a6286de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a88c936327f9d62ba7e606cbf5fccab23">getName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the log implementation as it would be specified in the config file.  <a href="#a88c936327f9d62ba7e606cbf5fccab23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a4f5d68a1e78453d838b4406f4405bc4f">getSizeBytes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the entire log in bytes.  <a href="#a4f5d68a1e78453d838b4406f4405bc4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classLogCabin_1_1Storage_1_1Log_1_1Sync.html">Log::Sync</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a49998df90ec65f822e87a11d6f51a3e7">takeSync</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get and remove the <a class="el" href="classLogCabin_1_1Storage_1_1Log.html" title="This interface is used by RaftConsensus to store log entries and metadata.">Log</a>'s <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html" title="Queues various operations on files, such as writes and fsyncs, to be executed later.">Sync</a> object in order to wait on it.  <a href="#a49998df90ec65f822e87a11d6f51a3e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab034af1c0809bf63323d46949822b69c">syncCompleteVirtual</a> (std::unique_ptr&lt; <a class="el" href="classLogCabin_1_1Storage_1_1Log_1_1Sync.html">Log::Sync</a> &gt; sync)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a06075f64815be30f9f3d56034d799f34">truncatePrefix</a> (uint64_t firstIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the log entries before the given index.  <a href="#a06075f64815be30f9f3d56034d799f34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab6e085a74854607aea7e8399d1f05f87">truncateSuffix</a> (uint64_t lastIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the log entries past the given index.  <a href="#ab6e085a74854607aea7e8399d1f05f87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a407a902bbab599d48cf4f83ab6fb41bb">updateMetadata</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this after changing <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a407704019cb95cc426ec03e78d26071e" title="The metadata this class mintains.">metadata</a>.  <a href="#a407a902bbab599d48cf4f83ab6fb41bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#acf6f1ee375ee34d73adee605da59a584">updateServerStats</a> (Protocol::ServerStats &amp;serverStats) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add information about the log's state to the given structure.  <a href="#acf6f1ee375ee34d73adee605da59a584"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceLogCabin_1_1Core_1_1Time.html#a4798c7e2244561626e4ce819710e7e56">Core::Time::SteadyClock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a65cfca4c2152293bf6b3deb796ea0cfe">Clock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock used for measuring disk performance.  <a href="#a65cfca4c2152293bf6b3deb796ea0cfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structLogCabin_1_1Core_1_1Time_1_1MockableClock.html#a25005848397dad2ae0d03826a755d7c8">Clock::time_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a33b9e1951fe268841a6b75d180435add">TimePoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Time point for measuring disk performance.  <a href="#a33b9e1951fe268841a6b75d180435add"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a239f30ef5449254ab9ebd0cb9598b1f6">readSegmentFilenames</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List the files in <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a3653051d472d1f62ab474b4101076446" title="The directory containing every file this log creates.">dir</a> and create <a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html" title="An open or closed segment.">Segment</a> objects for any of them that look like segments.  <a href="#a239f30ef5449254ab9ebd0cb9598b1f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a68946ecf450cc965b1ad0561a3455f3a">readMetadata</a> (const std::string &amp;filename, SegmentedLogMetadata::Metadata &amp;<a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a407704019cb95cc426ec03e78d26071e">metadata</a>, bool quiet) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a metadata file from disk.  <a href="#a68946ecf450cc965b1ad0561a3455f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa55ae05788df9d090c875dc1b82f2267">loadClosedSegment</a> (<a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a> &amp;segment, uint64_t <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aaf005740e234acbfd657046eaea19865">logStartIndex</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the given closed segment from disk, issuing PANICs and WARNINGs appropriately.  <a href="#aa55ae05788df9d090c875dc1b82f2267"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a457babadc678e65279f85d0997a7f3f2">loadOpenSegment</a> (<a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a> &amp;segment, uint64_t <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aaf005740e234acbfd657046eaea19865">logStartIndex</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the given open segment from disk, issuing PANICs and WARNINGs appropriately, and closing the segment.  <a href="#a457babadc678e65279f85d0997a7f3f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a9412657050c3b5ee0f15d13a687e031e">checkInvariants</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run through a bunch of assertions of class invariants (for debugging).  <a href="#a9412657050c3b5ee0f15d13a687e031e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a09027cf6c7aa1869f1a24837b4494eb7">closeSegment</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the open segment if one is open.  <a href="#a09027cf6c7aa1869f1a24837b4494eb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a2ff5aade1f854285b605fcefbe8d2a13">getOpenSegment</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the current open segment (the one that new writes should go into).  <a href="#a2ff5aade1f854285b605fcefbe8d2a13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a4ebf746ec25f37c00b636d707115beb5">getOpenSegment</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a3ce2b038faf15bf6da4f7992bd7ed482">openNewSegment</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a new open segment for the log head.  <a href="#a3ce2b038faf15bf6da4f7992bd7ed482"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa7c541cbed809b7dbfe7541b2c789d15">readProtoFromFile</a> (const <a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FilesystemUtil::File</a> &amp;file, <a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1FileContents.html">FilesystemUtil::FileContents</a> &amp;reader, uint64_t *offset, google::protobuf::Message *out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next ProtoBuf record out of 'file'.  <a href="#aa7c541cbed809b7dbfe7541b2c789d15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLogCabin_1_1Core_1_1Buffer.html">Core::Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa855cdc3f98b40e3b1ad09118cbd8db3">serializeProto</a> (const google::protobuf::Message &amp;in) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a ProtoBuf record to be written to disk.  <a href="#aa855cdc3f98b40e3b1ad09118cbd8db3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, <br class="typebreak"/>
<a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FilesystemUtil::File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a428a4dd73370ddbff7dfe151c03f60fe">prepareNewSegment</a> (uint64_t fileId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file for a new segment and allocates its space on disk.  <a href="#a428a4dd73370ddbff7dfe151c03f60fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a7f579c84b2363ff95de91ced5bd041e2">segmentPreparerMain</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function for the <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa0118a6fca6d83903ac7f5cc5f6b35e1" title="Opens files, allocates the to full size, and places them on preparedSegments for the log to use...">segmentPreparer</a> thread.  <a href="#a7f579c84b2363ff95de91ced5bd041e2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5503ea75df765ff0302604d2c0f9cfdf">Encoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a20c878fca260c1fea2dbae7905ce827e">encoding</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how individual records are stored.  <a href="#a20c878fca260c1fea2dbae7905ce827e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a34485601251390adc6b38fb2848e9a43">checksumAlgorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The algorithm to use when writing new records.  <a href="#a34485601251390adc6b38fb2848e9a43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad45c8da67feb145bf972bbc7c1f15136">MAX_SEGMENT_SIZE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size in bytes for newly written segments.  <a href="#ad45c8da67feb145bf972bbc7c1f15136"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad54138be8052e2963053757e8734f0d2">shouldCheckInvariants</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a9412657050c3b5ee0f15d13a687e031e" title="Run through a bunch of assertions of class invariants (for debugging).">checkInvariants()</a> should do its job, or set to false for performance.  <a href="#ad54138be8052e2963053757e8734f0d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a517d127cdb1fa64bbbb6042ad30a4cee">diskWriteDurationThreshold</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If a disk operation exceeds this much time, log a warning.  <a href="#a517d127cdb1fa64bbbb6042ad30a4cee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SegmentedLogMetadata::Metadata&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a407704019cb95cc426ec03e78d26071e">metadata</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The metadata this class mintains.  <a href="#a407704019cb95cc426ec03e78d26071e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FilesystemUtil::File</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a3653051d472d1f62ab474b4101076446">dir</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The directory containing every file this log creates.  <a href="#a3653051d472d1f62ab474b4101076446"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FilesystemUtil::File</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad2e8dbc33ff4ceae1b4f349cacd0b149">openSegmentFile</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable OS-level file that contains the entries for the current open segment.  <a href="#ad2e8dbc33ff4ceae1b4f349cacd0b149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aaf005740e234acbfd657046eaea19865">logStartIndex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the first entry in the log, see <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad729715c9512554255bb0670f6c385a2" title="Get the index of the first entry in the log (whether or not this entry exists).">getLogStartIndex()</a>.  <a href="#aaf005740e234acbfd657046eaea19865"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; uint64_t, <a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a34832b93004e1e5163d41bfb0a86dac6">segmentsByStartIndex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered map of all closed segments and the open segment, indexed by the startIndex of each segment.  <a href="#a34832b93004e1e5163d41bfb0a86dac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ae1ab06082b556d977f44610e9fb50693">totalClosedSegmentBytes</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of bytes occupied by the closed segments on disk.  <a href="#ae1ab06082b556d977f44610e9fb50693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1PreparedSegments.html">PreparedSegments</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a82ace8371782747c371bdadb29d41741">preparedSegments</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1PreparedSegments.html" title="A producer/consumer monitor for a queue of files to use for open segments.">PreparedSegments</a>.  <a href="#a82ace8371782747c371bdadb29d41741"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html">SegmentedLog::Sync</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a18dac48574a56e1edc5f6702bdd08f64">currentSync</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates deferred filesystem operations for <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ae0b3ea9703e373566d879928296eae16" title="Start to append new entries to the log.">append()</a> and <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a06075f64815be30f9f3d56034d799f34" title="Delete the log entries before the given index.">truncatePrefix()</a>.  <a href="#a18dac48574a56e1edc5f6702bdd08f64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLogCabin_1_1Core_1_1RollingStat.html">Core::RollingStat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab11c0f815da06fd00ef3f1812657f3b1">metadataWriteNanos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the time it takes to write a metadata file.  <a href="#ab11c0f815da06fd00ef3f1812657f3b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLogCabin_1_1Core_1_1RollingStat.html">Core::RollingStat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5e9b315d9ab8bb031f0edf8a8adc376f">filesystemOpsNanos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the time it takes to execute wait() on a <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html" title="Queues various operations on files, such as writes and fsyncs, to be executed later.">Sync</a> object.  <a href="#a5e9b315d9ab8bb031f0edf8a8adc376f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa0118a6fca6d83903ac7f5cc5f6b35e1">segmentPreparer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens files, allocates the to full size, and places them on <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a82ace8371782747c371bdadb29d41741" title="See PreparedSegments.">preparedSegments</a> for the log to use.  <a href="#aa0118a6fca6d83903ac7f5cc5f6b35e1"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class persists a log on the filesystem efficiently. </p>
<p>The log entries on disk are stored in a series of files called segments, and each segment is about 8MB in size. Thus, most small appends do not need to update filesystem metadata and can proceed with a single consecutive disk write.</p>
<p>The disk files consist of metadata files, closed segments, and open segments. Metadata files are used to track Raft metadata, such as the server's current term, and also the log's start index. Segments contain contiguous entries that are part of the log. Closed segments are never written to again (but may be renamed and truncated if a suffix of the log is truncated). Open segments are where newly appended entries go. Once an open segment reaches MAX_SEGMENT_SIZE, it is closed and a new one is used.</p>
<p>Metadata files are named "metadata1" and "metadata2". The code alternates between these so that there is always at least one readable metadata file. On boot, the readable metadata file with the higher version number is used.</p>
<p>Closed segments are named by the format string "%020lu-%020lu" with their start and end indexes, both inclusive. Closed segments always contain at least one entry; the end index is always at least as large as the start index. Closed segment files may occasionally include data past their filename's end index (these are ignored but a WARNING is issued). This can happen if the suffix of the segment is truncated and a crash occurs at an inopportune time (the segment file is first renamed, then truncated, and a crash occurs in between).</p>
<p>Open segments are named by the format string "open-%lu" with a unique number. These should not exist when the server shuts down cleanly, but they exist while the server is running and may be left around during a crash. Open segments either contain entries which come after the last closed segment or are full of zeros. When the server crashes while appending to an open segment, the end of that file may be corrupt. We can't distinguish between a corrupt file and a partially written entry. The code assumes it's a partially written entry, issues a WARNING, and ignores it.</p>
<p>Truncating a suffix of the log will remove all entries that are no longer part of the log. Truncating a prefix of the log will only remove complete segments that are before the new log start index. For example, if a segment has entries 10 through 20 and the prefix of the log is truncated to start at entry 15, that entire segment will be retained.</p>
<p>Each segment file starts with a segment header, which currently contains just a one-byte version number for the format of that segment. The current format (version 1) is just a concatenation of serialized entry records. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00089">89</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a65cfca4c2152293bf6b3deb796ea0cfe"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::Clock" ref="a65cfca4c2152293bf6b3deb796ea0cfe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceLogCabin_1_1Core_1_1Time.html#a4798c7e2244561626e4ce819710e7e56">Core::Time::SteadyClock</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a65cfca4c2152293bf6b3deb796ea0cfe">LogCabin::Storage::SegmentedLog::Clock</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clock used for measuring disk performance. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00093">93</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33b9e1951fe268841a6b75d180435add"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::TimePoint" ref="a33b9e1951fe268841a6b75d180435add" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structLogCabin_1_1Core_1_1Time_1_1MockableClock.html#a25005848397dad2ae0d03826a755d7c8">Clock::time_point</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a33b9e1951fe268841a6b75d180435add">LogCabin::Storage::SegmentedLog::TimePoint</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Time point for measuring disk performance. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00097">97</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a5503ea75df765ff0302604d2c0f9cfdf"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::Encoding" ref="a5503ea75df765ff0302604d2c0f9cfdf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5503ea75df765ff0302604d2c0f9cfdf">LogCabin::Storage::SegmentedLog::Encoding</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies how individual records are serialized. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5503ea75df765ff0302604d2c0f9cfdfa5db6da2c8f11776b6ecde090b58f0dd9"></a><!-- doxytag: member="TEXT" ref="a5503ea75df765ff0302604d2c0f9cfdfa5db6da2c8f11776b6ecde090b58f0dd9" args="" -->TEXT</em>&nbsp;</td><td>
<p>ProtoBuf human-readable text format. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5503ea75df765ff0302604d2c0f9cfdfa7e0644cff2ba996c4e8b01bf72ed6820"></a><!-- doxytag: member="BINARY" ref="a5503ea75df765ff0302604d2c0f9cfdfa7e0644cff2ba996c4e8b01bf72ed6820" args="" -->BINARY</em>&nbsp;</td><td>
<p>ProtoBuf binary format. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00104">104</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab667337be23393a649a61ca8f515af7b"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::SegmentedLog" ref="ab667337be23393a649a61ca8f515af7b" args="(const FilesystemUtil::File &amp;parentDir, Encoding encoding, const Core::Config &amp;config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab667337be23393a649a61ca8f515af7b">LogCabin::Storage::SegmentedLog::SegmentedLog</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FilesystemUtil::File</a> &amp;&#160;</td>
          <td class="paramname"><em>parentDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5503ea75df765ff0302604d2c0f9cfdf">Encoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLogCabin_1_1Core_1_1Config.html">Core::Config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">parentDir</td><td>A filesystem directory in which all the files for this storage module are kept. </td></tr>
    <tr><td class="paramname">encoding</td><td>Specifies how individual records are stored. </td></tr>
    <tr><td class="paramname">config</td><td>Settings. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00346">346</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3665b28b42b618a022ab40ed88969345"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::~SegmentedLog" ref="a3665b28b42b618a022ab40ed88969345" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a3665b28b42b618a022ab40ed88969345">LogCabin::Storage::SegmentedLog::~SegmentedLog</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00465">465</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae0b3ea9703e373566d879928296eae16"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::append" ref="ae0b3ea9703e373566d879928296eae16" args="(const std::vector&lt; const Entry * &gt; &amp;entries)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, uint64_t &gt; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ae0b3ea9703e373566d879928296eae16">LogCabin::Storage::SegmentedLog::append</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a8ca64ace5d6ae6f0175186c595d4fbe0">Entry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start to append new entries to the log. </p>
<p>The entries may not be on disk yet when this returns; see <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html" title="Queues various operations on files, such as writes and fsyncs, to be executed later.">Sync</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>Entries to place at the end of the log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Range of indexes of the new entries in the log, inclusive. </dd></dl>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#ab006b493d5e63b4bf84fb3567fc03d51">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00491">491</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af54cbc6f31d77719f3fe8d699b5c94da"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::getEntry" ref="af54cbc6f31d77719f3fe8d699b5c94da" args="(uint64_t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a8ca64ace5d6ae6f0175186c595d4fbe0">SegmentedLog::Entry</a> &amp; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#af54cbc6f31d77719f3fe8d699b5c94da">LogCabin::Storage::SegmentedLog::getEntry</a> </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Look up an entry by its log index. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Must be in the range [<a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad729715c9512554255bb0670f6c385a2" title="Get the index of the first entry in the log (whether or not this entry exists).">getLogStartIndex()</a>, <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a45c575000cfd56c3d77d6efa7a6286de" title="Get the index of the most recent entry in the log.">getLastLogIndex()</a>]. Otherwise, this will crash the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The entry corresponding to that index. This reference is only guaranteed to be valid until the next time the log is modified. </dd></dl>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a8a7efeea930f2b56dd90e8796abf6c82">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00575">575</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad729715c9512554255bb0670f6c385a2"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::getLogStartIndex" ref="ad729715c9512554255bb0670f6c385a2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad729715c9512554255bb0670f6c385a2">LogCabin::Storage::SegmentedLog::getLogStartIndex</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the index of the first entry in the log (whether or not this entry exists). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 for logs that have never had truncatePrefix called, otherwise the largest index passed to truncatePrefix. </dd></dl>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a5d995c35a5bf8ac1a28eadb83a04525e">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00592">592</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a45c575000cfd56c3d77d6efa7a6286de"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::getLastLogIndex" ref="a45c575000cfd56c3d77d6efa7a6286de" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a45c575000cfd56c3d77d6efa7a6286de">LogCabin::Storage::SegmentedLog::getLastLogIndex</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the index of the most recent entry in the log. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the most recent entry in the log, or <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad729715c9512554255bb0670f6c385a2" title="Get the index of the first entry in the log (whether or not this entry exists).">getLogStartIndex()</a> - 1 if the log is empty. </dd></dl>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a75616a93cbe7839f1ad6247b7e865a46">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00598">598</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a88c936327f9d62ba7e606cbf5fccab23"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::getName" ref="a88c936327f9d62ba7e606cbf5fccab23" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a88c936327f9d62ba7e606cbf5fccab23">LogCabin::Storage::SegmentedLog::getName</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the name of the log implementation as it would be specified in the config file. </p>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#abd90715c67f4fa038111259feacdede1">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00610">610</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4f5d68a1e78453d838b4406f4405bc4f"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::getSizeBytes" ref="a4f5d68a1e78453d838b4406f4405bc4f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a4f5d68a1e78453d838b4406f4405bc4f">LogCabin::Storage::SegmentedLog::getSizeBytes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of the entire log in bytes. </p>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a73b678e98d205870c19ac73ecfd5c807">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00619">619</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a49998df90ec65f822e87a11d6f51a3e7"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::takeSync" ref="a49998df90ec65f822e87a11d6f51a3e7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classLogCabin_1_1Storage_1_1Log_1_1Sync.html">Log::Sync</a> &gt; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a49998df90ec65f822e87a11d6f51a3e7">LogCabin::Storage::SegmentedLog::takeSync</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get and remove the <a class="el" href="classLogCabin_1_1Storage_1_1Log.html" title="This interface is used by RaftConsensus to store log entries and metadata.">Log</a>'s <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html" title="Queues various operations on files, such as writes and fsyncs, to be executed later.">Sync</a> object in order to wait on it. </p>
<p>This <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html" title="Queues various operations on files, such as writes and fsyncs, to be executed later.">Sync</a> object must later be returned to the <a class="el" href="classLogCabin_1_1Storage_1_1Log.html" title="This interface is used by RaftConsensus to store log entries and metadata.">Log</a> with <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#ab99aa495171e1e60aab8b6b65df3d56f" title="Release resources attached to the Sync object.">syncComplete()</a>.</p>
<p>While <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a49998df90ec65f822e87a11d6f51a3e7" title="Get and remove the Log&#39;s Sync object in order to wait on it.">takeSync()</a> and <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#ab99aa495171e1e60aab8b6b65df3d56f" title="Release resources attached to the Sync object.">syncComplete()</a> may not be done concurrently with other <a class="el" href="classLogCabin_1_1Storage_1_1Log.html" title="This interface is used by RaftConsensus to store log entries and metadata.">Log</a> operations, <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html#aa40fcc5e7877bf0bb2df88bd9aff54cf" title="Wait for the log entries to be durable.">Sync::wait()</a> may be done concurrently with all operations except <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab6e085a74854607aea7e8399d1f05f87" title="Delete the log entries past the given index.">truncateSuffix()</a>. </p>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#aabf3345e03685b44d56b607ebbe282c9">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00625">625</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab034af1c0809bf63323d46949822b69c"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::syncCompleteVirtual" ref="ab034af1c0809bf63323d46949822b69c" args="(std::unique_ptr&lt; Log::Sync &gt; sync)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab034af1c0809bf63323d46949822b69c">LogCabin::Storage::SegmentedLog::syncCompleteVirtual</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classLogCabin_1_1Storage_1_1Log_1_1Sync.html">Log::Sync</a> &gt;&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00635">635</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a06075f64815be30f9f3d56034d799f34"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::truncatePrefix" ref="a06075f64815be30f9f3d56034d799f34" args="(uint64_t firstIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a06075f64815be30f9f3d56034d799f34">LogCabin::Storage::SegmentedLog::truncatePrefix</a> </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>firstIndex</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the log entries before the given index. </p>
<p>Once you truncate a prefix from the log, there's no way to undo this. The entries may still be on disk when this returns and file descriptors and other resources may remain open; see <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html" title="Queues various operations on files, such as writes and fsyncs, to be executed later.">Sync</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">firstIndex</td><td>After this call, the log will contain no entries indexed less than firstIndex. This can be any log index, including 0 and those past the end of the log. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a75237d59c0f0aeb45e0fe2425e7daea5">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00642">642</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab6e085a74854607aea7e8399d1f05f87"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::truncateSuffix" ref="ab6e085a74854607aea7e8399d1f05f87" args="(uint64_t lastIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab6e085a74854607aea7e8399d1f05f87">LogCabin::Storage::SegmentedLog::truncateSuffix</a> </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lastIndex</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the log entries past the given index. </p>
<p>This will not affect the log start index. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lastIndex</td><td>After this call, the log will contain no entries indexed greater than lastIndex. This can be any log index, including 0 and those past the end of the log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Callers should wait() on all <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html" title="Queues various operations on files, such as writes and fsyncs, to be executed later.">Sync</a> object prior to calling <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab6e085a74854607aea7e8399d1f05f87" title="Delete the log entries past the given index.">truncateSuffix()</a>. This never happens on leaders, so it's not a real limitation, but things may go wonky otherwise. </dd></dl>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a166833dce487be2a51f28ce2b0d03852">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00679">679</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a407a902bbab599d48cf4f83ab6fb41bb"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::updateMetadata" ref="a407a902bbab599d48cf4f83ab6fb41bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a407a902bbab599d48cf4f83ab6fb41bb">LogCabin::Storage::SegmentedLog::updateMetadata</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this after changing <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a407704019cb95cc426ec03e78d26071e" title="The metadata this class mintains.">metadata</a>. </p>

<p>Implements <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#affd60dcee3571e1afc169cf36d887a13">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00758">758</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="acf6f1ee375ee34d73adee605da59a584"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::updateServerStats" ref="acf6f1ee375ee34d73adee605da59a584" args="(Protocol::ServerStats &amp;serverStats) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#acf6f1ee375ee34d73adee605da59a584">LogCabin::Storage::SegmentedLog::updateServerStats</a> </td>
          <td>(</td>
          <td class="paramtype">Protocol::ServerStats &amp;&#160;</td>
          <td class="paramname"><em>serverStats</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add information about the log's state to the given structure. </p>
<p>Used for diagnostics. </p>

<p>Reimplemented from <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a3bdbcbd9789cfa2de387e7f8c0eb7f1e">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00803">803</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a239f30ef5449254ab9ebd0cb9598b1f6"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::readSegmentFilenames" ref="a239f30ef5449254ab9ebd0cb9598b1f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">SegmentedLog::Segment</a> &gt; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a239f30ef5449254ab9ebd0cb9598b1f6">LogCabin::Storage::SegmentedLog::readSegmentFilenames</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List the files in <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a3653051d472d1f62ab474b4101076446" title="The directory containing every file this log creates.">dir</a> and create <a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html" title="An open or closed segment.">Segment</a> objects for any of them that look like segments. </p>
<p>This is only used during initialization. These segments are passed through <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa55ae05788df9d090c875dc1b82f2267" title="Read the given closed segment from disk, issuing PANICs and WARNINGs appropriately.">loadClosedSegment()</a> and <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a457babadc678e65279f85d0997a7f3f2" title="Read the given open segment from disk, issuing PANICs and WARNINGs appropriately, and closing the seg...">loadOpenSegment()</a> next. Also updates SegmentPreparer::filenameCounter. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Partially initialized <a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html" title="An open or closed segment.">Segment</a> objects, one per discovered filename. </dd></dl>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00818">818</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a68946ecf450cc965b1ad0561a3455f3a"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::readMetadata" ref="a68946ecf450cc965b1ad0561a3455f3a" args="(const std::string &amp;filename, SegmentedLogMetadata::Metadata &amp;metadata, bool quiet) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a68946ecf450cc965b1ad0561a3455f3a">LogCabin::Storage::SegmentedLog::readMetadata</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentedLogMetadata::Metadata &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quiet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a metadata file from disk. </p>
<p>This is only used during initialization. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>Filename within <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a3653051d472d1f62ab474b4101076446" title="The directory containing every file this log creates.">dir</a> to attempt to open and read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">metadata</td><td>Where the contents of the file end up. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">quiet</td><td>Set to true to avoid warnings when the file can't be read; used in unit tests. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the file was read successfully, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00876">876</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa55ae05788df9d090c875dc1b82f2267"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::loadClosedSegment" ref="aa55ae05788df9d090c875dc1b82f2267" args="(Segment &amp;segment, uint64_t logStartIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa55ae05788df9d090c875dc1b82f2267">LogCabin::Storage::SegmentedLog::loadClosedSegment</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>logStartIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the given closed segment from disk, issuing PANICs and WARNINGs appropriately. </p>
<p>This is only used during initialization.</p>
<p>Deletes segment if its last index is below logStartIndex.</p>
<p>Reads every entry described in the filename, and PANICs if any of those can't be read.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">segment</td><td>Closed segment to read from disk. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">logStartIndex</td><td>The index of the first entry in the log, according to the log metadata. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the segment is valid; false if it has been removed entirely from disk. </dd></dl>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00910">910</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a457babadc678e65279f85d0997a7f3f2"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::loadOpenSegment" ref="a457babadc678e65279f85d0997a7f3f2" args="(Segment &amp;segment, uint64_t logStartIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a457babadc678e65279f85d0997a7f3f2">LogCabin::Storage::SegmentedLog::loadOpenSegment</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>logStartIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the given open segment from disk, issuing PANICs and WARNINGs appropriately, and closing the segment. </p>
<p>This is only used during initialization.</p>
<p>Reads up through the end of the file or the last entry with a valid checksum. If any valid entries are read, the segment is truncated and closed. Otherwise, it is removed.</p>
<p>Deletes segment if its last index is below logStartIndex.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">segment</td><td>Open segment to read from disk. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">logStartIndex</td><td>The index of the first entry in the log, according to the log metadata. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the segment is valid; false if it has been removed entirely from disk. </dd></dl>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l00980">980</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9412657050c3b5ee0f15d13a687e031e"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::checkInvariants" ref="a9412657050c3b5ee0f15d13a687e031e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a9412657050c3b5ee0f15d13a687e031e">LogCabin::Storage::SegmentedLog::checkInvariants</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run through a bunch of assertions of class invariants (for debugging). </p>
<p>For example, there should always be one open segment. See <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad54138be8052e2963053757e8734f0d2" title="Set to true if checkInvariants() should do its job, or set to false for performance.">shouldCheckInvariants</a>, controlled by the config option 'storageDebug', and the BUILDTYPE. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l01082">1082</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a09027cf6c7aa1869f1a24837b4494eb7"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::closeSegment" ref="a09027cf6c7aa1869f1a24837b4494eb7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a09027cf6c7aa1869f1a24837b4494eb7">LogCabin::Storage::SegmentedLog::closeSegment</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the open segment if one is open. </p>
<p>This removes the open segment if it is empty, or closes it otherwise. Since it's a class invariant that there is always an open segment, the caller should open a new segment after calling this (unless it's shutting down). </p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l01132">1132</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a2ff5aade1f854285b605fcefbe8d2a13"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::getOpenSegment" ref="a2ff5aade1f854285b605fcefbe8d2a13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">SegmentedLog::Segment</a> &amp; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a2ff5aade1f854285b605fcefbe8d2a13">LogCabin::Storage::SegmentedLog::getOpenSegment</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the current open segment (the one that new writes should go into). </p>
<p>Crashes if there is no open segment (but it's an invariant of this class to maintain one). </p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l01171">1171</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4ebf746ec25f37c00b636d707115beb5"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::getOpenSegment" ref="a4ebf746ec25f37c00b636d707115beb5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">SegmentedLog::Segment</a> &amp; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a2ff5aade1f854285b605fcefbe8d2a13">LogCabin::Storage::SegmentedLog::getOpenSegment</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l01178">1178</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce2b038faf15bf6da4f7992bd7ed482"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::openNewSegment" ref="a3ce2b038faf15bf6da4f7992bd7ed482" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a3ce2b038faf15bf6da4f7992bd7ed482">LogCabin::Storage::SegmentedLog::openNewSegment</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up a new open segment for the log head. </p>
<p>This is called when <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ae0b3ea9703e373566d879928296eae16" title="Start to append new entries to the log.">append()</a> needs more space but also when the end of the log is truncated with <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a06075f64815be30f9f3d56034d799f34" title="Delete the log entries before the given index.">truncatePrefix()</a> or <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab6e085a74854607aea7e8399d1f05f87" title="Delete the log entries past the given index.">truncateSuffix()</a>. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>There is no currently open segment. </dd></dl>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l01185">1185</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa7c541cbed809b7dbfe7541b2c789d15"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::readProtoFromFile" ref="aa7c541cbed809b7dbfe7541b2c789d15" args="(const FilesystemUtil::File &amp;file, FilesystemUtil::FileContents &amp;reader, uint64_t *offset, google::protobuf::Message *out) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa7c541cbed809b7dbfe7541b2c789d15">LogCabin::Storage::SegmentedLog::readProtoFromFile</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FilesystemUtil::File</a> &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1FileContents.html">FilesystemUtil::FileContents</a> &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">google::protobuf::Message *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the next ProtoBuf record out of 'file'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">file</td><td>The open file, useful for error messages. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">reader</td><td>A reader for 'file'. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offset</td><td>The byte offset in the file at which to start reading as input. The byte just after the last byte of data as output if successful, otherwise unmodified. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>An empty ProtoBuf to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Empty string if successful, otherwise error message.</dd></dl>
<p>Format:</p>
<p>|checksum|dataLen|data|</p>
<p>The checksum is up to <a class="el" href="namespaceLogCabin_1_1Core_1_1Checksum.html#a1982d4ee28f2bcb1c81861691fda7c31abb2b22ec01561b5d03e4f8c85a8d9d4a">Core::Checksum::MAX_LENGTH</a> bytes and is terminated by a null character. It covers both dataLen and data.</p>
<p>dataLen is an unsigned integer (8 bytes, big-endian byte order) that specifies the length in bytes of data.</p>
<p>data is a protobuf encoded as binary or text, depending on encoding. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l01205">1205</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa855cdc3f98b40e3b1ad09118cbd8db3"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::serializeProto" ref="aa855cdc3f98b40e3b1ad09118cbd8db3" args="(const google::protobuf::Message &amp;in) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Core_1_1Buffer.html">Core::Buffer</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa855cdc3f98b40e3b1ad09118cbd8db3">LogCabin::Storage::SegmentedLog::serializeProto</a> </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Message &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare a ProtoBuf record to be written to disk. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>ProtoBuf to be serialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Buffer containing serialized record. </dd></dl>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l01264">1264</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a428a4dd73370ddbff7dfe151c03f60fe"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::prepareNewSegment" ref="a428a4dd73370ddbff7dfe151c03f60fe" args="(uint64_t fileId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, <a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FS::File</a> &gt; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a428a4dd73370ddbff7dfe151c03f60fe">LogCabin::Storage::SegmentedLog::prepareNewSegment</a> </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>fileId</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens a file for a new segment and allocates its space on disk. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fileId</td><td>ID to use to generate filename; see SegmentPreparer::filenameCounter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Filename and writable OS-level file. </dd></dl>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l01312">1312</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a7f579c84b2363ff95de91ced5bd041e2"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::segmentPreparerMain" ref="a7f579c84b2363ff95de91ced5bd041e2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a7f579c84b2363ff95de91ced5bd041e2">LogCabin::Storage::SegmentedLog::segmentPreparerMain</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main function for the <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa0118a6fca6d83903ac7f5cc5f6b35e1" title="Opens files, allocates the to full size, and places them on preparedSegments for the log to use...">segmentPreparer</a> thread. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8cc_source.html#l01344">1344</a> of file <a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a20c878fca260c1fea2dbae7905ce827e"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::encoding" ref="a20c878fca260c1fea2dbae7905ce827e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5503ea75df765ff0302604d2c0f9cfdf">Encoding</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a20c878fca260c1fea2dbae7905ce827e">LogCabin::Storage::SegmentedLog::encoding</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies how individual records are stored. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00565">565</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="a34485601251390adc6b38fb2848e9a43"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::checksumAlgorithm" ref="a34485601251390adc6b38fb2848e9a43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a34485601251390adc6b38fb2848e9a43">LogCabin::Storage::SegmentedLog::checksumAlgorithm</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The algorithm to use when writing new records. </p>
<p>When reading records, any available checksum is used. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00571">571</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad45c8da67feb145bf972bbc7c1f15136"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::MAX_SEGMENT_SIZE" ref="ad45c8da67feb145bf972bbc7c1f15136" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad45c8da67feb145bf972bbc7c1f15136">LogCabin::Storage::SegmentedLog::MAX_SEGMENT_SIZE</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum size in bytes for newly written segments. </p>
<p>Controlled by the 'storageSegmentBytes' config option. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00577">577</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad54138be8052e2963053757e8734f0d2"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::shouldCheckInvariants" ref="ad54138be8052e2963053757e8734f0d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad54138be8052e2963053757e8734f0d2">LogCabin::Storage::SegmentedLog::shouldCheckInvariants</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set to true if <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a9412657050c3b5ee0f15d13a687e031e" title="Run through a bunch of assertions of class invariants (for debugging).">checkInvariants()</a> should do its job, or set to false for performance. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00583">583</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="a517d127cdb1fa64bbbb6042ad30a4cee"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::diskWriteDurationThreshold" ref="a517d127cdb1fa64bbbb6042ad30a4cee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::chrono::milliseconds <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a517d127cdb1fa64bbbb6042ad30a4cee">LogCabin::Storage::SegmentedLog::diskWriteDurationThreshold</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If a disk operation exceeds this much time, log a warning. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00588">588</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="a407704019cb95cc426ec03e78d26071e"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::metadata" ref="a407704019cb95cc426ec03e78d26071e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SegmentedLogMetadata::Metadata <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a407704019cb95cc426ec03e78d26071e">LogCabin::Storage::SegmentedLog::metadata</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The metadata this class mintains. </p>
<p>This should be combined with the superclass's metadata when being written out to disk. </p>

<p>Reimplemented from <a class="el" href="classLogCabin_1_1Storage_1_1Log.html#a3044e83ee00115379349495937630463">LogCabin::Storage::Log</a>.</p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00594">594</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3653051d472d1f62ab474b4101076446"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::dir" ref="a3653051d472d1f62ab474b4101076446" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FilesystemUtil::File</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a3653051d472d1f62ab474b4101076446">LogCabin::Storage::SegmentedLog::dir</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The directory containing every file this log creates. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00599">599</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad2e8dbc33ff4ceae1b4f349cacd0b149"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::openSegmentFile" ref="ad2e8dbc33ff4ceae1b4f349cacd0b149" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Storage_1_1FilesystemUtil_1_1File.html">FilesystemUtil::File</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad2e8dbc33ff4ceae1b4f349cacd0b149">LogCabin::Storage::SegmentedLog::openSegmentFile</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A writable OS-level file that contains the entries for the current open segment. </p>
<p>It is a class invariant that this is always a valid file. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00605">605</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaf005740e234acbfd657046eaea19865"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::logStartIndex" ref="aaf005740e234acbfd657046eaea19865" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aaf005740e234acbfd657046eaea19865">LogCabin::Storage::SegmentedLog::logStartIndex</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The index of the first entry in the log, see <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ad729715c9512554255bb0670f6c385a2" title="Get the index of the first entry in the log (whether or not this entry exists).">getLogStartIndex()</a>. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00610">610</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="a34832b93004e1e5163d41bfb0a86dac6"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::segmentsByStartIndex" ref="a34832b93004e1e5163d41bfb0a86dac6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;uint64_t, <a class="el" href="structLogCabin_1_1Storage_1_1SegmentedLog_1_1Segment.html">Segment</a>&gt; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a34832b93004e1e5163d41bfb0a86dac6">LogCabin::Storage::SegmentedLog::segmentsByStartIndex</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ordered map of all closed segments and the open segment, indexed by the startIndex of each segment. </p>
<p>This is used to support all the key operations, such as looking up an entry and truncation. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00617">617</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae1ab06082b556d977f44610e9fb50693"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::totalClosedSegmentBytes" ref="ae1ab06082b556d977f44610e9fb50693" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ae1ab06082b556d977f44610e9fb50693">LogCabin::Storage::SegmentedLog::totalClosedSegmentBytes</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The total number of bytes occupied by the closed segments on disk. </p>
<p>Used to calculate <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a4f5d68a1e78453d838b4406f4405bc4f" title="Get the size of the entire log in bytes.">getSizeBytes()</a> efficiently. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00623">623</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="a82ace8371782747c371bdadb29d41741"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::preparedSegments" ref="a82ace8371782747c371bdadb29d41741" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1PreparedSegments.html">PreparedSegments</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a82ace8371782747c371bdadb29d41741">LogCabin::Storage::SegmentedLog::preparedSegments</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>See <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1PreparedSegments.html" title="A producer/consumer monitor for a queue of files to use for open segments.">PreparedSegments</a>. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00628">628</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="a18dac48574a56e1edc5f6702bdd08f64"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::currentSync" ref="a18dac48574a56e1edc5f6702bdd08f64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html">SegmentedLog::Sync</a>&gt; <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a18dac48574a56e1edc5f6702bdd08f64">LogCabin::Storage::SegmentedLog::currentSync</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulates deferred filesystem operations for <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ae0b3ea9703e373566d879928296eae16" title="Start to append new entries to the log.">append()</a> and <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a06075f64815be30f9f3d56034d799f34" title="Delete the log entries before the given index.">truncatePrefix()</a>. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00634">634</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab11c0f815da06fd00ef3f1812657f3b1"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::metadataWriteNanos" ref="ab11c0f815da06fd00ef3f1812657f3b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Core_1_1RollingStat.html">Core::RollingStat</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#ab11c0f815da06fd00ef3f1812657f3b1">LogCabin::Storage::SegmentedLog::metadataWriteNanos</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tracks the time it takes to write a metadata file. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00639">639</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9b315d9ab8bb031f0edf8a8adc376f"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::filesystemOpsNanos" ref="a5e9b315d9ab8bb031f0edf8a8adc376f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLogCabin_1_1Core_1_1RollingStat.html">Core::RollingStat</a> <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a5e9b315d9ab8bb031f0edf8a8adc376f">LogCabin::Storage::SegmentedLog::filesystemOpsNanos</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tracks the time it takes to execute wait() on a <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog_1_1Sync.html" title="Queues various operations on files, such as writes and fsyncs, to be executed later.">Sync</a> object. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00644">644</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa0118a6fca6d83903ac7f5cc5f6b35e1"></a><!-- doxytag: member="LogCabin::Storage::SegmentedLog::segmentPreparer" ref="aa0118a6fca6d83903ac7f5cc5f6b35e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::thread <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#aa0118a6fca6d83903ac7f5cc5f6b35e1">LogCabin::Storage::SegmentedLog::segmentPreparer</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens files, allocates the to full size, and places them on <a class="el" href="classLogCabin_1_1Storage_1_1SegmentedLog.html#a82ace8371782747c371bdadb29d41741" title="See PreparedSegments.">preparedSegments</a> for the log to use. </p>

<p>Definition at line <a class="el" href="SegmentedLog_8h_source.html#l00650">650</a> of file <a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Storage/<a class="el" href="SegmentedLog_8h_source.html">SegmentedLog.h</a></li>
<li>Storage/<a class="el" href="SegmentedLog_8cc_source.html">SegmentedLog.cc</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
